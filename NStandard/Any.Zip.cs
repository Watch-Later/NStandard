// <auto-generated/>
using System;
using System.Collections.Generic;
using System.Linq;

namespace NStandard
{
    public static partial class Any
    {
        #region ValueTuple
#if NET5_0_OR_GREATER || NETSTANDARD2_0_OR_GREATER
        /// <summary>
        ///    Produces a sequence of tuples with elements from the specified sequences.
        /// </summary>
        public static IEnumerable<IEnumerable<T1>> Zip<T1>(IEnumerable<IEnumerable<T1>> args)
        {
            IEnumerator<T1>[] enumerators = args.Select(x => x.GetEnumerator()).ToArray();
            while (enumerators.All(x => x.MoveNext()))
            {
                yield return enumerators.Select(e => e.Current);
            }
        }
        /// <summary>
        ///    Produces a sequence of tuples with elements from the specified sequences.
        /// </summary>
        public static IEnumerable<(T1, T2)> Zip<T1, T2>(
            IEnumerable<T1> arg1,
            IEnumerable<T2> arg2
        )
        {
            using IEnumerator<T1> e1 = arg1.GetEnumerator();
            using IEnumerator<T2> e2 = arg2.GetEnumerator();

            while (e1.MoveNext()
                && e2.MoveNext())
            {
                yield return (
                    e1.Current,
                    e2.Current
                );
            }
        }
        /// <summary>
        ///    Produces a sequence of tuples with elements from the specified sequences.
        /// </summary>
        public static IEnumerable<(T1, T2, T3)> Zip<T1, T2, T3>(
            IEnumerable<T1> arg1,
            IEnumerable<T2> arg2,
            IEnumerable<T3> arg3
        )
        {
            using IEnumerator<T1> e1 = arg1.GetEnumerator();
            using IEnumerator<T2> e2 = arg2.GetEnumerator();
            using IEnumerator<T3> e3 = arg3.GetEnumerator();

            while (e1.MoveNext()
                && e2.MoveNext()
                && e3.MoveNext())
            {
                yield return (
                    e1.Current,
                    e2.Current,
                    e3.Current
                );
            }
        }
        /// <summary>
        ///    Produces a sequence of tuples with elements from the specified sequences.
        /// </summary>
        public static IEnumerable<(T1, T2, T3, T4)> Zip<T1, T2, T3, T4>(
            IEnumerable<T1> arg1,
            IEnumerable<T2> arg2,
            IEnumerable<T3> arg3,
            IEnumerable<T4> arg4
        )
        {
            using IEnumerator<T1> e1 = arg1.GetEnumerator();
            using IEnumerator<T2> e2 = arg2.GetEnumerator();
            using IEnumerator<T3> e3 = arg3.GetEnumerator();
            using IEnumerator<T4> e4 = arg4.GetEnumerator();

            while (e1.MoveNext()
                && e2.MoveNext()
                && e3.MoveNext()
                && e4.MoveNext())
            {
                yield return (
                    e1.Current,
                    e2.Current,
                    e3.Current,
                    e4.Current
                );
            }
        }
        /// <summary>
        ///    Produces a sequence of tuples with elements from the specified sequences.
        /// </summary>
        public static IEnumerable<(T1, T2, T3, T4, T5)> Zip<T1, T2, T3, T4, T5>(
            IEnumerable<T1> arg1,
            IEnumerable<T2> arg2,
            IEnumerable<T3> arg3,
            IEnumerable<T4> arg4,
            IEnumerable<T5> arg5
        )
        {
            using IEnumerator<T1> e1 = arg1.GetEnumerator();
            using IEnumerator<T2> e2 = arg2.GetEnumerator();
            using IEnumerator<T3> e3 = arg3.GetEnumerator();
            using IEnumerator<T4> e4 = arg4.GetEnumerator();
            using IEnumerator<T5> e5 = arg5.GetEnumerator();

            while (e1.MoveNext()
                && e2.MoveNext()
                && e3.MoveNext()
                && e4.MoveNext()
                && e5.MoveNext())
            {
                yield return (
                    e1.Current,
                    e2.Current,
                    e3.Current,
                    e4.Current,
                    e5.Current
                );
            }
        }
        /// <summary>
        ///    Produces a sequence of tuples with elements from the specified sequences.
        /// </summary>
        public static IEnumerable<(T1, T2, T3, T4, T5, T6)> Zip<T1, T2, T3, T4, T5, T6>(
            IEnumerable<T1> arg1,
            IEnumerable<T2> arg2,
            IEnumerable<T3> arg3,
            IEnumerable<T4> arg4,
            IEnumerable<T5> arg5,
            IEnumerable<T6> arg6
        )
        {
            using IEnumerator<T1> e1 = arg1.GetEnumerator();
            using IEnumerator<T2> e2 = arg2.GetEnumerator();
            using IEnumerator<T3> e3 = arg3.GetEnumerator();
            using IEnumerator<T4> e4 = arg4.GetEnumerator();
            using IEnumerator<T5> e5 = arg5.GetEnumerator();
            using IEnumerator<T6> e6 = arg6.GetEnumerator();

            while (e1.MoveNext()
                && e2.MoveNext()
                && e3.MoveNext()
                && e4.MoveNext()
                && e5.MoveNext()
                && e6.MoveNext())
            {
                yield return (
                    e1.Current,
                    e2.Current,
                    e3.Current,
                    e4.Current,
                    e5.Current,
                    e6.Current
                );
            }
        }
        /// <summary>
        ///    Produces a sequence of tuples with elements from the specified sequences.
        /// </summary>
        public static IEnumerable<(T1, T2, T3, T4, T5, T6, T7)> Zip<T1, T2, T3, T4, T5, T6, T7>(
            IEnumerable<T1> arg1,
            IEnumerable<T2> arg2,
            IEnumerable<T3> arg3,
            IEnumerable<T4> arg4,
            IEnumerable<T5> arg5,
            IEnumerable<T6> arg6,
            IEnumerable<T7> arg7
        )
        {
            using IEnumerator<T1> e1 = arg1.GetEnumerator();
            using IEnumerator<T2> e2 = arg2.GetEnumerator();
            using IEnumerator<T3> e3 = arg3.GetEnumerator();
            using IEnumerator<T4> e4 = arg4.GetEnumerator();
            using IEnumerator<T5> e5 = arg5.GetEnumerator();
            using IEnumerator<T6> e6 = arg6.GetEnumerator();
            using IEnumerator<T7> e7 = arg7.GetEnumerator();

            while (e1.MoveNext()
                && e2.MoveNext()
                && e3.MoveNext()
                && e4.MoveNext()
                && e5.MoveNext()
                && e6.MoveNext()
                && e7.MoveNext())
            {
                yield return (
                    e1.Current,
                    e2.Current,
                    e3.Current,
                    e4.Current,
                    e5.Current,
                    e6.Current,
                    e7.Current
                );
            }
        }
        /// <summary>
        ///    Produces a sequence of tuples with elements from the specified sequences.
        /// </summary>
        public static IEnumerable<(T1, T2, T3, T4, T5, T6, T7, T8)> Zip<T1, T2, T3, T4, T5, T6, T7, T8>(
            IEnumerable<T1> arg1,
            IEnumerable<T2> arg2,
            IEnumerable<T3> arg3,
            IEnumerable<T4> arg4,
            IEnumerable<T5> arg5,
            IEnumerable<T6> arg6,
            IEnumerable<T7> arg7,
            IEnumerable<T8> arg8
        )
        {
            using IEnumerator<T1> e1 = arg1.GetEnumerator();
            using IEnumerator<T2> e2 = arg2.GetEnumerator();
            using IEnumerator<T3> e3 = arg3.GetEnumerator();
            using IEnumerator<T4> e4 = arg4.GetEnumerator();
            using IEnumerator<T5> e5 = arg5.GetEnumerator();
            using IEnumerator<T6> e6 = arg6.GetEnumerator();
            using IEnumerator<T7> e7 = arg7.GetEnumerator();
            using IEnumerator<T8> e8 = arg8.GetEnumerator();

            while (e1.MoveNext()
                && e2.MoveNext()
                && e3.MoveNext()
                && e4.MoveNext()
                && e5.MoveNext()
                && e6.MoveNext()
                && e7.MoveNext()
                && e8.MoveNext())
            {
                yield return (
                    e1.Current,
                    e2.Current,
                    e3.Current,
                    e4.Current,
                    e5.Current,
                    e6.Current,
                    e7.Current,
                    e8.Current
                );
            }
        }
#endif
        #endregion

        #region with Selector
        /// <summary>
        ///    Applies a specified function to the corresponding elements of many sequences,
        ///    producing a sequence of the results.
        /// </summary>
        public static IEnumerable<TRet> Zip<T1, TRet>(IEnumerable<IEnumerable<T1>> args, Func<IEnumerable<T1>, TRet> resultSelector)
        {
            IEnumerator<T1>[] enumerators = args.Select(x => x.GetEnumerator()).ToArray();
            while (enumerators.All(x => x.MoveNext()))
            {
                yield return resultSelector(enumerators.Select(e => e.Current));
            }
        }
        /// <summary>
        ///    Applies a specified function to the corresponding elements of many sequences,
        ///    producing a sequence of the results.
        /// </summary>
        public static IEnumerable<TRet> Zip<T1, T2, TRet>(
            IEnumerable<T1> arg1,
            IEnumerable<T2> arg2,
            Func<T1, T2, TRet> resultSelector
        )
        {
            using IEnumerator<T1> e1 = arg1.GetEnumerator();
            using IEnumerator<T2> e2 = arg2.GetEnumerator();

            while (e1.MoveNext()
                && e2.MoveNext())
            {
                yield return resultSelector(
                    e1.Current,
                    e2.Current
                );
            }
        }
        /// <summary>
        ///    Applies a specified function to the corresponding elements of many sequences,
        ///    producing a sequence of the results.
        /// </summary>
        public static IEnumerable<TRet> Zip<T1, T2, T3, TRet>(
            IEnumerable<T1> arg1,
            IEnumerable<T2> arg2,
            IEnumerable<T3> arg3,
            Func<T1, T2, T3, TRet> resultSelector
        )
        {
            using IEnumerator<T1> e1 = arg1.GetEnumerator();
            using IEnumerator<T2> e2 = arg2.GetEnumerator();
            using IEnumerator<T3> e3 = arg3.GetEnumerator();

            while (e1.MoveNext()
                && e2.MoveNext()
                && e3.MoveNext())
            {
                yield return resultSelector(
                    e1.Current,
                    e2.Current,
                    e3.Current
                );
            }
        }
        /// <summary>
        ///    Applies a specified function to the corresponding elements of many sequences,
        ///    producing a sequence of the results.
        /// </summary>
        public static IEnumerable<TRet> Zip<T1, T2, T3, T4, TRet>(
            IEnumerable<T1> arg1,
            IEnumerable<T2> arg2,
            IEnumerable<T3> arg3,
            IEnumerable<T4> arg4,
            Func<T1, T2, T3, T4, TRet> resultSelector
        )
        {
            using IEnumerator<T1> e1 = arg1.GetEnumerator();
            using IEnumerator<T2> e2 = arg2.GetEnumerator();
            using IEnumerator<T3> e3 = arg3.GetEnumerator();
            using IEnumerator<T4> e4 = arg4.GetEnumerator();

            while (e1.MoveNext()
                && e2.MoveNext()
                && e3.MoveNext()
                && e4.MoveNext())
            {
                yield return resultSelector(
                    e1.Current,
                    e2.Current,
                    e3.Current,
                    e4.Current
                );
            }
        }

#if NET5_0_OR_GREATER || NETSTANDARD2_0_OR_GREATER || NET40_OR_GREATER
        /// <summary>
        ///    Applies a specified function to the corresponding elements of many sequences,
        ///    producing a sequence of the results.
        /// </summary>
        public static IEnumerable<TRet> Zip<T1, T2, T3, T4, T5, TRet>(
            IEnumerable<T1> arg1,
            IEnumerable<T2> arg2,
            IEnumerable<T3> arg3,
            IEnumerable<T4> arg4,
            IEnumerable<T5> arg5,
            Func<T1, T2, T3, T4, T5, TRet> resultSelector
        )
        {
            using IEnumerator<T1> e1 = arg1.GetEnumerator();
            using IEnumerator<T2> e2 = arg2.GetEnumerator();
            using IEnumerator<T3> e3 = arg3.GetEnumerator();
            using IEnumerator<T4> e4 = arg4.GetEnumerator();
            using IEnumerator<T5> e5 = arg5.GetEnumerator();

            while (e1.MoveNext()
                && e2.MoveNext()
                && e3.MoveNext()
                && e4.MoveNext()
                && e5.MoveNext())
            {
                yield return resultSelector(
                    e1.Current,
                    e2.Current,
                    e3.Current,
                    e4.Current,
                    e5.Current
                );
            }
        }
        /// <summary>
        ///    Applies a specified function to the corresponding elements of many sequences,
        ///    producing a sequence of the results.
        /// </summary>
        public static IEnumerable<TRet> Zip<T1, T2, T3, T4, T5, T6, TRet>(
            IEnumerable<T1> arg1,
            IEnumerable<T2> arg2,
            IEnumerable<T3> arg3,
            IEnumerable<T4> arg4,
            IEnumerable<T5> arg5,
            IEnumerable<T6> arg6,
            Func<T1, T2, T3, T4, T5, T6, TRet> resultSelector
        )
        {
            using IEnumerator<T1> e1 = arg1.GetEnumerator();
            using IEnumerator<T2> e2 = arg2.GetEnumerator();
            using IEnumerator<T3> e3 = arg3.GetEnumerator();
            using IEnumerator<T4> e4 = arg4.GetEnumerator();
            using IEnumerator<T5> e5 = arg5.GetEnumerator();
            using IEnumerator<T6> e6 = arg6.GetEnumerator();

            while (e1.MoveNext()
                && e2.MoveNext()
                && e3.MoveNext()
                && e4.MoveNext()
                && e5.MoveNext()
                && e6.MoveNext())
            {
                yield return resultSelector(
                    e1.Current,
                    e2.Current,
                    e3.Current,
                    e4.Current,
                    e5.Current,
                    e6.Current
                );
            }
        }
        /// <summary>
        ///    Applies a specified function to the corresponding elements of many sequences,
        ///    producing a sequence of the results.
        /// </summary>
        public static IEnumerable<TRet> Zip<T1, T2, T3, T4, T5, T6, T7, TRet>(
            IEnumerable<T1> arg1,
            IEnumerable<T2> arg2,
            IEnumerable<T3> arg3,
            IEnumerable<T4> arg4,
            IEnumerable<T5> arg5,
            IEnumerable<T6> arg6,
            IEnumerable<T7> arg7,
            Func<T1, T2, T3, T4, T5, T6, T7, TRet> resultSelector
        )
        {
            using IEnumerator<T1> e1 = arg1.GetEnumerator();
            using IEnumerator<T2> e2 = arg2.GetEnumerator();
            using IEnumerator<T3> e3 = arg3.GetEnumerator();
            using IEnumerator<T4> e4 = arg4.GetEnumerator();
            using IEnumerator<T5> e5 = arg5.GetEnumerator();
            using IEnumerator<T6> e6 = arg6.GetEnumerator();
            using IEnumerator<T7> e7 = arg7.GetEnumerator();

            while (e1.MoveNext()
                && e2.MoveNext()
                && e3.MoveNext()
                && e4.MoveNext()
                && e5.MoveNext()
                && e6.MoveNext()
                && e7.MoveNext())
            {
                yield return resultSelector(
                    e1.Current,
                    e2.Current,
                    e3.Current,
                    e4.Current,
                    e5.Current,
                    e6.Current,
                    e7.Current
                );
            }
        }
        /// <summary>
        ///    Applies a specified function to the corresponding elements of many sequences,
        ///    producing a sequence of the results.
        /// </summary>
        public static IEnumerable<TRet> Zip<T1, T2, T3, T4, T5, T6, T7, T8, TRet>(
            IEnumerable<T1> arg1,
            IEnumerable<T2> arg2,
            IEnumerable<T3> arg3,
            IEnumerable<T4> arg4,
            IEnumerable<T5> arg5,
            IEnumerable<T6> arg6,
            IEnumerable<T7> arg7,
            IEnumerable<T8> arg8,
            Func<T1, T2, T3, T4, T5, T6, T7, T8, TRet> resultSelector
        )
        {
            using IEnumerator<T1> e1 = arg1.GetEnumerator();
            using IEnumerator<T2> e2 = arg2.GetEnumerator();
            using IEnumerator<T3> e3 = arg3.GetEnumerator();
            using IEnumerator<T4> e4 = arg4.GetEnumerator();
            using IEnumerator<T5> e5 = arg5.GetEnumerator();
            using IEnumerator<T6> e6 = arg6.GetEnumerator();
            using IEnumerator<T7> e7 = arg7.GetEnumerator();
            using IEnumerator<T8> e8 = arg8.GetEnumerator();

            while (e1.MoveNext()
                && e2.MoveNext()
                && e3.MoveNext()
                && e4.MoveNext()
                && e5.MoveNext()
                && e6.MoveNext()
                && e7.MoveNext()
                && e8.MoveNext())
            {
                yield return resultSelector(
                    e1.Current,
                    e2.Current,
                    e3.Current,
                    e4.Current,
                    e5.Current,
                    e6.Current,
                    e7.Current,
                    e8.Current
                );
            }
        }
#endif
        #endregion
    }
}

